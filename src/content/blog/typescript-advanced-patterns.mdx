---
title: "TypeScript 上級者向けパターンとテクニック"
description: "TypeScriptの型システムを最大限活用するための高度なパターンを解説。Conditional Types、Template Literal Types、Brand Types など実務で使える実践的なテクニック集。"
pubDate: 2024-01-24
heroImage: "/images/sample.png"
tags: ["TypeScript", "型システム", "上級", "デザインパターン", "型安全性"]
draft: false
---

import LinkCard from '../../components/LinkCard.astro';
import LinkCardSimple from '../../components/LinkCardSimple.astro';

# TypeScript 上級者向けパターンとテクニック

TypeScriptの型システムは非常に強力で、適切に活用することで実行時エラーを大幅に削減できます。この記事では、実務で役立つ高度な型パターンを実例とともに紹介します。

![TypeScript 上級パターン](/images/sample.png)

## 1. Conditional Types（条件付き型）

### 基本的な条件付き型

条件によって異なる型を返すConditional Typesは、非常に柔軟な型定義を可能にします。

```typescript
// 基本的な条件付き型
type IsArray<T> = T extends Array<any> ? true : false;

type Test1 = IsArray<string[]>;  // true
type Test2 = IsArray<number>;    // false

// より実用的な例：関数の戻り値型を推論
type ReturnType<T> = T extends (...args: any[]) => infer R ? R : never;

type FuncReturnType = ReturnType<() => string>;  // string
type AsyncReturnType = ReturnType<() => Promise<number>>;  // Promise<number>
```

### Distributive Conditional Types

Union型に対して条件付き型を適用すると、各メンバーに対して分配されます。

```typescript
// Distributive Conditional Types
type ToArray<T> = T extends any ? T[] : never;

type StringOrNumberArray = ToArray<string | number>;
// string[] | number[] （(string | number)[] ではない）

// Non-distributive にしたい場合
type ToArrayNonDistributive<T> = [T] extends [any] ? T[] : never;

type UnionArray = ToArrayNonDistributive<string | number>;
// (string | number)[]
```

### 実用例：APIレスポンス型の推論

```typescript
// APIレスポンスの型を動的に推論
type ApiResponse<T> = {
  data: T;
  status: 'success' | 'error';
  message?: string;
};

type ExtractData<T> = T extends ApiResponse<infer U> ? U : never;

// 使用例
type UserResponse = ApiResponse<{ id: number; name: string }>;
type UserData = ExtractData<UserResponse>;  // { id: number; name: string }

// 複雑なネストされた型も対応
type NestedResponse = ApiResponse<{ users: User[]; pagination: PaginationInfo }>;
type NestedData = ExtractData<NestedResponse>;  // { users: User[]; pagination: PaginationInfo }
```

## 2. Template Literal Types

### 基本的なTemplate Literal Types

文字列の型レベル操作が可能になります。

```typescript
// 基本的なTemplate Literal Types
type Greeting = `Hello, ${string}!`;

type WelcomeMessage = `Welcome, ${'Admin' | 'User' | 'Guest'}`;
// "Welcome, Admin" | "Welcome, User" | "Welcome, Guest"

// より複雑な例：イベント名の生成
type EventType = 'click' | 'focus' | 'blur';
type ElementType = 'button' | 'input' | 'div';

type EventHandler = `on${Capitalize<EventType>}${Capitalize<ElementType>}`;
// "onClickButton" | "onFocusButton" | "onBlurButton" | 
// "onClickInput" | "onFocusInput" | "onBlurInput" | 
// "onClickDiv" | "onFocusDiv" | "onBlurDiv"
```

### CSS-in-JSでの活用

```typescript
// CSS プロパティの型安全な定義
type CSSUnit = 'px' | 'em' | 'rem' | '%' | 'vh' | 'vw';
type CSSValue<T extends string> = `${number}${T}` | '0';

type Margin = CSSValue<'px'> | CSSValue<'em'> | CSSValue<'rem'>;
type Color = `#${string}` | `rgb(${number}, ${number}, ${number})` | `hsl(${number}, ${number}%, ${number}%)`;

interface StyledProps {
  margin?: Margin;
  color?: Color;
  fontSize?: CSSValue<'px' | 'em' | 'rem'>;
}

// 使用例
const styles: StyledProps = {
  margin: '10px',      // ✅
  color: '#ff0000',    // ✅
  fontSize: '1.2rem',  // ✅
  // margin: '10',     // ❌ 単位が必要
  // color: 'red',     // ❌ 無効なカラーフォーマット
};
```

### ルーティングシステムでの型安全性

```typescript
// ルートパスの型定義
type Routes = {
  '/': {};
  '/users': {};
  '/users/:id': { id: string };
  '/posts/:postId/comments/:commentId': { postId: string; commentId: string };
};

// パラメータを抽出する型
type ExtractParams<T extends string> = 
  T extends `${infer _Start}:${infer Param}/${infer Rest}`
    ? { [K in Param]: string } & ExtractParams<`/${Rest}`>
    : T extends `${infer _Start}:${infer Param}`
    ? { [K in Param]: string }
    : {};

type UserParams = ExtractParams<'/users/:id'>;  // { id: string }
type CommentParams = ExtractParams<'/posts/:postId/comments/:commentId'>;  
// { postId: string; commentId: string }

// 型安全なルーター関数
function navigate<T extends keyof Routes>(
  path: T,
  ...args: Routes[T] extends {} ? [Routes[T]] : []
) {
  // 実装...
}

// 使用例
navigate('/');                              // ✅
navigate('/users');                         // ✅
navigate('/users/:id', { id: '123' });     // ✅
// navigate('/users/:id');                  // ❌ パラメータが必要
// navigate('/users/:id', { name: 'John' });// ❌ 間違ったパラメータ
```

<img 
  src="/images/sample.png" 
  alt="TypeScript Template Literal Typesの図解" 
  width="600"
  style="border-radius: 8px; margin: 1.5rem 0;"
/>

## 3. Brand Types（ブランド型）

### プリミティブ型の区別

同じプリミティブ型でも意味的に異なる値を型レベルで区別できます。

```typescript
// Brand Types の定義
type Brand<T, K> = T & { readonly __brand: K };

type UserId = Brand<number, 'UserId'>;
type ProductId = Brand<number, 'ProductId'>;
type Email = Brand<string, 'Email'>;
type PhoneNumber = Brand<string, 'PhoneNumber'>;

// ファクトリ関数
function createUserId(id: number): UserId {
  return id as UserId;
}

function createEmail(email: string): Email {
  // バリデーション
  if (!email.includes('@')) {
    throw new Error('Invalid email format');
  }
  return email as Email;
}

// 使用例
function getUser(userId: UserId) {
  // 実装...
}

function getProduct(productId: ProductId) {
  // 実装...
}

const userId = createUserId(123);
const productId = createUserId(456) as ProductId;  // 明示的キャスト

getUser(userId);       // ✅
// getUser(productId); // ❌ 型エラー
// getUser(123);       // ❌ 生の number は不可
```

### 値の検証を含むBrand Types

```typescript
// より高度なBrand Types
abstract class Validated<T, K> {
  readonly __brand!: K;
  protected constructor(public readonly value: T) {}
}

class Email extends Validated<string, 'Email'> {
  private constructor(value: string) {
    super(value);
  }

  static create(value: string): Email | Error {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(value)) {
      return new Error('Invalid email format');
    }
    return new Email(value);
  }

  toString(): string {
    return this.value;
  }
}

class PhoneNumber extends Validated<string, 'PhoneNumber'> {
  private constructor(value: string) {
    super(value);
  }

  static create(value: string): PhoneNumber | Error {
    const phoneRegex = /^\+?[\d\s-()]+$/;
    if (!phoneRegex.test(value)) {
      return new Error('Invalid phone number format');
    }
    return new PhoneNumber(value);
  }

  toString(): string {
    return this.value;
  }
}

// 使用例
const emailResult = Email.create('user@example.com');
const phoneResult = PhoneNumber.create('+1-234-567-8900');

if (emailResult instanceof Email) {
  console.log(`Email: ${emailResult.toString()}`);
}

if (phoneResult instanceof Error) {
  console.error(phoneResult.message);
}
```

## 4. Mapped Types と Key Remapping

### 既存の型を変換

```typescript
// 基本的なMapped Types
type Partial<T> = {
  [P in keyof T]?: T[P];
};

type Required<T> = {
  [P in keyof T]-?: T[P];
};

// カスタムMapped Types
type Stringify<T> = {
  [K in keyof T]: string;
};

type Nullify<T> = {
  [K in keyof T]: T[K] | null;
};

interface User {
  id: number;
  name: string;
  email: string;
  isActive: boolean;
}

type UserStrings = Stringify<User>;
// { id: string; name: string; email: string; isActive: string }

type NullableUser = Nullify<User>;
// { id: number | null; name: string | null; email: string | null; isActive: boolean | null }
```

### Key Remapping による高度な変換

```typescript
// Key Remapping でキー名を変更
type Getters<T> = {
  [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K];
};

type Setters<T> = {
  [K in keyof T as `set${Capitalize<string & K>}`]: (value: T[K]) => void;
};

type UserGetters = Getters<User>;
// {
//   getId: () => number;
//   getName: () => string;
//   getEmail: () => string;
//   getIsActive: () => boolean;
// }

type UserSetters = Setters<User>;
// {
//   setId: (value: number) => void;
//   setName: (value: string) => void;
//   setEmail: (value: string) => void;
//   setIsActive: (value: boolean) => void;
// }

// 条件付きキー選択
type PickByType<T, U> = {
  [K in keyof T as T[K] extends U ? K : never]: T[K];
};

type UserStrings = PickByType<User, string>;
// { name: string; email: string }

type UserNumbers = PickByType<User, number>;
// { id: number }
```

## 5. Higher-Order Types

### 型レベルでの関数合成

```typescript
// 型レベル関数の合成
type Compose<F, G> = F extends (x: infer A) => infer B
  ? G extends (x: B) => infer C
    ? (x: A) => C
    : never
  : never;

type ToString = (x: number) => string;
type ToUpperCase = (x: string) => string;

type NumberToUpperString = Compose<ToString, ToUpperCase>;
// (x: number) => string

// より複雑な例：Promiseの連鎖
type Chain<T, F> = T extends Promise<infer U>
  ? F extends (x: U) => infer R
    ? Promise<R>
    : never
  : F extends (x: T) => infer R
    ? R
    : never;

declare function fetchUser(): Promise<User>;
declare function getProfile(user: User): Profile;

type ChainedResult = Chain<ReturnType<typeof fetchUser>, typeof getProfile>;
// Promise<Profile>
```

### Recursive Types

```typescript
// 再帰的な型定義
type DeepReadonly<T> = {
  readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P];
};

type NestedObject = {
  user: {
    profile: {
      name: string;
      settings: {
        theme: string;
        notifications: boolean;
      };
    };
  };
};

type ReadonlyNested = DeepReadonly<NestedObject>;
// すべてのプロパティが readonly になる

// JSON のような構造の型定義
type JSONValue = 
  | string
  | number
  | boolean
  | null
  | JSONValue[]
  | { [key: string]: JSONValue };

type Config = {
  database: {
    host: string;
    port: number;
    credentials: {
      username: string;
      password: string;
    };
  };
  features: string[];
  debug: boolean;
};

const config: Config = {
  database: {
    host: 'localhost',
    port: 5432,
    credentials: {
      username: 'admin',
      password: 'secret'
    }
  },
  features: ['auth', 'logging'],
  debug: true
};
```

<figure style="margin: 2rem 0; text-align: center;">
  <img 
    src="/images/sample.png" 
    alt="TypeScript再帰型の構造図" 
    width="600"
    style="border-radius: 8px;"
  />
  <figcaption style="margin-top: 0.5rem; font-size: 0.875rem; color: #6b7280; font-style: italic;">
    図1: 再帰的な型定義による深いネスト構造の表現
  </figcaption>
</figure>

## 6. 実用的なユーティリティ型

### フォームバリデーションのための型

```typescript
// バリデーションルールの型定義
type ValidationRule<T> = {
  required?: boolean;
  minLength?: T extends string ? number : never;
  maxLength?: T extends string ? number : never;
  min?: T extends number ? number : never;
  max?: T extends number ? number : never;
  pattern?: T extends string ? RegExp : never;
  custom?: (value: T) => boolean | string;
};

type FormSchema<T> = {
  [K in keyof T]: ValidationRule<T[K]>;
};

// フォームの型定義
interface LoginForm {
  email: string;
  password: string;
  age: number;
}

const loginSchema: FormSchema<LoginForm> = {
  email: {
    required: true,
    pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
  },
  password: {
    required: true,
    minLength: 8,
    maxLength: 50,
  },
  age: {
    required: true,
    min: 18,
    max: 120,
  },
};

// バリデーション結果の型
type ValidationResult<T> = {
  [K in keyof T]: {
    isValid: boolean;
    errors: string[];
  };
};

type LoginValidationResult = ValidationResult<LoginForm>;
```

### APIクライアントの型安全性

```typescript
// REST APIエンドポイントの型定義
type HTTPMethod = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';

type Endpoint<TMethod extends HTTPMethod, TPath extends string, TBody = never, TResponse = unknown> = {
  method: TMethod;
  path: TPath;
  body: TBody;
  response: TResponse;
};

// エンドポイント定義
type Endpoints = {
  getUsers: Endpoint<'GET', '/users', never, User[]>;
  getUser: Endpoint<'GET', '/users/:id', never, User>;
  createUser: Endpoint<'POST', '/users', CreateUserRequest, User>;
  updateUser: Endpoint<'PUT', '/users/:id', UpdateUserRequest, User>;
  deleteUser: Endpoint<'DELETE', '/users/:id', never, void>;
};

// 型安全なAPIクライアント
class APIClient {
  async call<K extends keyof Endpoints>(
    endpoint: K,
    ...args: Endpoints[K]['body'] extends never 
      ? [path?: string] 
      : [body: Endpoints[K]['body'], path?: string]
  ): Promise<Endpoints[K]['response']> {
    // 実装...
    throw new Error('Not implemented');
  }
}

// 使用例
const api = new APIClient();

// 型推論により正しい引数と戻り値の型が決まる
const users = await api.call('getUsers');        // User[]
const user = await api.call('getUser');          // User
const newUser = await api.call('createUser', {   // User
  name: 'John',
  email: 'john@example.com'
});
```

## 7. パフォーマンス最適化

### 型計算のパフォーマンス

```typescript
// 悪い例：深い再帰は TypeScript コンパイラに負荷
type BadDeepPick<T, K extends string> = K extends `${infer Key}.${infer Rest}`
  ? Key extends keyof T
    ? { [P in Key]: BadDeepPick<T[Key], Rest> }
    : never
  : K extends keyof T
    ? { [P in K]: T[K] }
    : never;

// 良い例：再帰の深さを制限
type DeepPick<T, K extends string, Depth extends ReadonlyArray<number> = []> = 
  Depth['length'] extends 10 // 最大10階層まで
    ? any
    : K extends `${infer Key}.${infer Rest}`
      ? Key extends keyof T
        ? { [P in Key]: DeepPick<T[Key], Rest, [...Depth, 1]> }
        : never
      : K extends keyof T
        ? { [P in K]: T[K] }
        : never;

// 型エイリアスの活用
type CommonProps = {
  id: string;
  createdAt: Date;
  updatedAt: Date;
};

// 毎回計算するのではなく、エイリアスを使用
interface User extends CommonProps {
  name: string;
  email: string;
}

interface Product extends CommonProps {
  name: string;
  price: number;
}
```

## まとめ

TypeScriptの高度な型システムを活用することで：

1. **実行時エラーの削減**: 型レベルでのバリデーション
2. **開発体験の向上**: 強力な型推論とIntelliSense
3. **リファクタリングの安全性**: 型システムによる変更の影響範囲検出
4. **APIの型安全性**: エンドポイントとレスポンスの型管理
5. **コードの自己文書化**: 型定義が仕様書の役割

これらのパターンを適切に使い分けることで、より保守性の高いTypeScriptコードを書くことができます。

---

## 関連記事

<LinkCardSimple 
  href="/blog/react-performance-optimization/"
  title="React パフォーマンス最適化の実践ガイド"
  description="TypeScriptと組み合わせたReactの型安全なパフォーマンス最適化"
/>

<LinkCardSimple 
  href="/blog/modern-web-development-2024/"
  title="2024年のモダンWeb開発トレンド"
  description="TypeScriptを活用したモダンな開発手法"
/>

## 参考リンク

<LinkCard 
  href="https://www.typescriptlang.org/docs/handbook/2/conditional-types.html"
  title="TypeScript - Conditional Types"
  description="TypeScript公式ドキュメントのConditional Types解説"
  external={true}
/>

<LinkCardSimple 
  href="https://github.com/type-challenges/type-challenges"
  title="Type Challenges"
  description="TypeScriptの型システムを学習するためのチャレンジ問題集"
  external={true}
/>

<LinkCardSimple 
  href="https://www.typescriptlang.org/play"
  title="TypeScript Playground"
  description="ブラウザでTypeScriptの型システムを試せる公式ツール"
  external={true}
/>