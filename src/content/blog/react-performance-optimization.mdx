---
title: "React パフォーマンス最適化の実践ガイド"
description: "Reactアプリケーションのパフォーマンスを劇的に改善する実践的な手法を解説。useMemo、useCallback、React.memoの適切な使い方から、バンドルサイズ最適化まで。"
pubDate: 2024-01-23
heroImage: "/images/sample.png"
tags: ["React", "パフォーマンス", "最適化", "JavaScript", "フロントエンド"]
draft: false
---

import LinkCard from '../../components/LinkCard.astro';
import LinkCardSimple from '../../components/LinkCardSimple.astro';

# React パフォーマンス最適化の実践ガイド

Reactアプリケーションが成長するにつれて、パフォーマンスの問題は避けて通れません。この記事では、実際のプロジェクトで使える最適化テクニックを体系的に解説します。

![React パフォーマンス最適化](/images/sample.png)

## 1. パフォーマンス測定の基礎

### React DevTools Profilerの活用

最適化の前に、まず現状を正確に把握することが重要です。

<LinkCard 
  href="https://react.dev/reference/react/Profiler"
  title="React Profiler API"
  description="React公式のProfiler APIドキュメント。コンポーネントのレンダリング性能を測定する方法を詳しく解説。"
  external={true}
/>

```jsx
import { Profiler } from 'react';

function onRenderCallback(id, phase, actualDuration) {
  console.log('Component:', id);
  console.log('Phase:', phase);
  console.log('Duration:', actualDuration);
}

function App() {
  return (
    <Profiler id="App" onRender={onRenderCallback}>
      <Header />
      <Main />
      <Footer />
    </Profiler>
  );
}
```

### Core Web Vitalsの監視

実際のユーザー体験を測定するために、Core Web Vitalsを監視しましょう。

```javascript
// Web Vitalsライブラリを使用した測定
import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';

function sendToAnalytics(metric) {
  console.log(metric);
  // アナリティクスサービスに送信
}

getCLS(sendToAnalytics);
getFID(sendToAnalytics);
getFCP(sendToAnalytics);
getLCP(sendToAnalytics);
getTTFB(sendToAnalytics);
```

## 2. レンダリング最適化

### React.memoによる不要な再レンダリング防止

コンポーネントの props が変わらない限り再レンダリングを防ぐことができます。

```jsx
import React, { memo } from 'react';

// 最適化前
function ExpensiveComponent({ data, onClick }) {
  console.log('ExpensiveComponent rendered');
  
  return (
    <div>
      {data.map(item => (
        <div key={item.id} onClick={() => onClick(item)}>
          {item.name}
        </div>
      ))}
    </div>
  );
}

// 最適化後
const OptimizedComponent = memo(function ExpensiveComponent({ data, onClick }) {
  console.log('OptimizedComponent rendered');
  
  return (
    <div>
      {data.map(item => (
        <div key={item.id} onClick={() => onClick(item)}>
          {item.name}
        </div>
      ))}
    </div>
  );
});
```

### useMemoによる重い計算の最適化

計算コストの高い処理をメモ化して、不要な再計算を防ぎます。

```jsx
import { useMemo } from 'react';

function ProductList({ products, filters }) {
  // 重い計算をメモ化
  const filteredProducts = useMemo(() => {
    console.log('Filtering products...');
    return products.filter(product => {
      return filters.every(filter => 
        product[filter.key] === filter.value
      );
    });
  }, [products, filters]);

  const totalPrice = useMemo(() => {
    console.log('Calculating total price...');
    return filteredProducts.reduce(
      (sum, product) => sum + product.price, 
      0
    );
  }, [filteredProducts]);

  return (
    <div>
      <p>Total: ${totalPrice}</p>
      {filteredProducts.map(product => (
        <ProductCard key={product.id} product={product} />
      ))}
    </div>
  );
}
```

### useCallbackによる関数の最適化

子コンポーネントに渡す関数をメモ化して、不要な再レンダリングを防ぎます。

```jsx
import { useCallback, useState } from 'react';

function TodoApp() {
  const [todos, setTodos] = useState([]);
  const [filter, setFilter] = useState('all');

  // useCallbackで関数をメモ化
  const addTodo = useCallback((text) => {
    setTodos(prev => [...prev, { 
      id: Date.now(), 
      text, 
      completed: false 
    }]);
  }, []);

  const toggleTodo = useCallback((id) => {
    setTodos(prev => prev.map(todo =>
      todo.id === id 
        ? { ...todo, completed: !todo.completed }
        : todo
    ));
  }, []);

  const deleteTodo = useCallback((id) => {
    setTodos(prev => prev.filter(todo => todo.id !== id));
  }, []);

  return (
    <div>
      <TodoForm onAdd={addTodo} />
      <TodoList 
        todos={todos}
        filter={filter}
        onToggle={toggleTodo}
        onDelete={deleteTodo}
      />
    </div>
  );
}
```

<img 
  src="/images/sample.png" 
  alt="React Hooks最適化の図解" 
  width="600"
  style="border-radius: 8px; margin: 1.5rem 0;"
/>

## 3. 仮想化による大量データの表示最適化

### react-windowを使った仮想スクロール

大量のリストアイテムを効率的に表示する方法です。

<LinkCardSimple 
  href="https://github.com/bvaughn/react-window"
  title="react-window"
  description="効率的な仮想スクロールを実現するReactライブラリ。大量データの表示パフォーマンスを劇的に改善。"
  external={true}
/>

```jsx
import { FixedSizeList as List } from 'react-window';

function VirtualizedList({ items }) {
  const Row = ({ index, style }) => (
    <div style={style}>
      <div className="item">
        {items[index].name}
      </div>
    </div>
  );

  return (
    <List
      height={600}      // コンテナの高さ
      itemCount={items.length}
      itemSize={50}     // 各アイテムの高さ
      width="100%"
    >
      {Row}
    </List>
  );
}

// 10,000件のデータでもスムーズに表示
function App() {
  const items = Array.from({ length: 10000 }, (_, i) => ({
    id: i,
    name: `Item ${i}`
  }));

  return <VirtualizedList items={items} />;
}
```

## 4. コード分割とLazy Loading

### React.lazyによるコンポーネントの遅延読み込み

必要になるまでコンポーネントの読み込みを遅延させます。

```jsx
import { Suspense, lazy } from 'react';

// 重いコンポーネントを遅延読み込み
const HeavyDashboard = lazy(() => import('./HeavyDashboard'));
const ReportsPage = lazy(() => import('./ReportsPage'));
const SettingsPage = lazy(() => import('./SettingsPage'));

function App() {
  const [currentPage, setCurrentPage] = useState('dashboard');

  const renderPage = () => {
    switch (currentPage) {
      case 'dashboard':
        return <HeavyDashboard />;
      case 'reports':
        return <ReportsPage />;
      case 'settings':
        return <SettingsPage />;
      default:
        return <div>Page not found</div>;
    }
  };

  return (
    <div>
      <nav>
        <button onClick={() => setCurrentPage('dashboard')}>
          Dashboard
        </button>
        <button onClick={() => setCurrentPage('reports')}>
          Reports
        </button>
        <button onClick={() => setCurrentPage('settings')}>
          Settings
        </button>
      </nav>
      
      <main>
        <Suspense fallback={<LoadingSpinner />}>
          {renderPage()}
        </Suspense>
      </main>
    </div>
  );
}
```

### 動的インポートによるライブラリの最適化

大きなライブラリも必要な時だけ読み込むことができます。

```jsx
import { useState } from 'react';

function ChartComponent({ data }) {
  const [Chart, setChart] = useState(null);
  const [loading, setLoading] = useState(false);

  const loadChart = async () => {
    if (Chart) return;
    
    setLoading(true);
    try {
      // Chart.jsを動的に読み込み
      const { Chart: ChartJS } = await import('chart.js/auto');
      setChart(() => ChartJS);
    } catch (error) {
      console.error('Failed to load chart library:', error);
    } finally {
      setLoading(false);
    }
  };

  if (!Chart) {
    return (
      <div>
        <button onClick={loadChart} disabled={loading}>
          {loading ? 'Loading...' : 'Show Chart'}
        </button>
      </div>
    );
  }

  return <canvas ref={canvasRef} />;
}
```

## 5. 状態管理の最適化

### Context の適切な分割

React Context を適切に分割することで、不要な再レンダリングを防げます。

```jsx
// 悪い例：すべてを一つのContextに
const AppContext = createContext();

// 良い例：用途別に分割
const UserContext = createContext();
const ThemeContext = createContext();
const NotificationContext = createContext();

function AppProvider({ children }) {
  return (
    <UserProvider>
      <ThemeProvider>
        <NotificationProvider>
          {children}
        </NotificationProvider>
      </ThemeProvider>
    </UserProvider>
  );
}
```

### Zustandによる軽量状態管理

Reduxよりもシンプルでパフォーマンスの良い状態管理ライブラリです。

<LinkCardSimple 
  href="https://github.com/pmndrs/zustand"
  title="Zustand"
  description="軽量でシンプルなReact状態管理ライブラリ。Reduxのボイラープレートを削減し、優れたパフォーマンスを提供。"
  external={true}
/>

```jsx
import { create } from 'zustand';

// ストアの定義
const useStore = create((set) => ({
  count: 0,
  todos: [],
  increment: () => set((state) => ({ count: state.count + 1 })),
  addTodo: (todo) => set((state) => ({ 
    todos: [...state.todos, todo] 
  })),
}));

// コンポーネントでの使用
function Counter() {
  const { count, increment } = useStore();
  
  return (
    <div>
      <span>{count}</span>
      <button onClick={increment}>+</button>
    </div>
  );
}

function TodoList() {
  const { todos, addTodo } = useStore();
  
  return (
    <div>
      {todos.map(todo => (
        <div key={todo.id}>{todo.text}</div>
      ))}
      <button onClick={() => addTodo({ id: Date.now(), text: 'New todo' })}>
        Add Todo
      </button>
    </div>
  );
}
```

## 6. バンドルサイズの最適化

### Tree Shakingの活用

使用していないコードを自動的に除去する設定です。

```javascript
// webpack.config.js
module.exports = {
  mode: 'production',
  optimization: {
    usedExports: true,
    sideEffects: false,
  },
};

// package.json
{
  "sideEffects": false
}
```

### Bundle Analyzerによる分析

バンドルサイズを視覚的に分析して最適化ポイントを発見します。

<LinkCardSimple 
  href="https://github.com/webpack-contrib/webpack-bundle-analyzer"
  title="Webpack Bundle Analyzer"
  description="Webpackバンドルの内容を視覚的に分析するツール。どのモジュールがサイズを占めているかを把握できる。"
  external={true}
/>

```bash
# インストール
npm install --save-dev webpack-bundle-analyzer

# 分析実行
npx webpack-bundle-analyzer build/static/js/*.js
```

<figure style="margin: 2rem 0; text-align: center;">
  <img 
    src="/images/sample.png" 
    alt="Bundle Analyzerの分析結果例" 
    width="600"
    style="border-radius: 8px;"
  />
  <figcaption style="margin-top: 0.5rem; font-size: 0.875rem; color: #6b7280; font-style: italic;">
    図1: Bundle Analyzerで可視化されたバンドルサイズ
  </figcaption>
</figure>

## 7. 画像とアセットの最適化

### 次世代画像フォーマットの活用

WebPやAVIF形式を使用してファイルサイズを削減します。

```jsx
function OptimizedImage({ src, alt, width, height }) {
  const webpSrc = src.replace(/\.(jpg|jpeg|png)$/i, '.webp');
  const avifSrc = src.replace(/\.(jpg|jpeg|png)$/i, '.avif');

  return (
    <picture>
      <source srcSet={avifSrc} type="image/avif" />
      <source srcSet={webpSrc} type="image/webp" />
      <img 
        src={src} 
        alt={alt} 
        width={width}
        height={height}
        loading="lazy"
        style={{ aspectRatio: `${width}/${height}` }}
      />
    </picture>
  );
}
```

### Progressive Image Loading

画像を段階的に読み込んでユーザー体験を向上させます。

```jsx
import { useState, useEffect } from 'react';

function ProgressiveImage({ placeholderSrc, src, alt, ...props }) {
  const [imageSrc, setImageSrc] = useState(placeholderSrc);
  const [isLoaded, setIsLoaded] = useState(false);

  useEffect(() => {
    const img = new Image();
    img.onload = () => {
      setImageSrc(src);
      setIsLoaded(true);
    };
    img.src = src;
  }, [src]);

  return (
    <img
      {...props}
      src={imageSrc}
      alt={alt}
      style={{
        ...props.style,
        filter: isLoaded ? 'none' : 'blur(5px)',
        transition: 'filter 0.3s ease',
      }}
    />
  );
}
```

## 8. パフォーマンス監視と継続的改善

### 自動化されたパフォーマンステスト

CI/CDパイプラインにパフォーマンステストを組み込みます。

```javascript
// lighthouse-ci.config.js
module.exports = {
  ci: {
    collect: {
      url: ['http://localhost:3000'],
      numberOfRuns: 3,
    },
    assert: {
      assertions: {
        'categories:performance': ['error', { minScore: 0.9 }],
        'categories:accessibility': ['error', { minScore: 0.9 }],
        'categories:best-practices': ['error', { minScore: 0.9 }],
        'categories:seo': ['error', { minScore: 0.9 }],
      },
    },
  },
};
```

### リアルユーザーモニタリング (RUM)

実際のユーザーのパフォーマンスデータを収集します。

```javascript
// RUMデータの収集
function collectRUMData() {
  // Navigation Timing API
  const navigation = performance.getEntriesByType('navigation')[0];
  
  const metrics = {
    dns: navigation.domainLookupEnd - navigation.domainLookupStart,
    tcp: navigation.connectEnd - navigation.connectStart,
    request: navigation.responseStart - navigation.requestStart,
    response: navigation.responseEnd - navigation.responseStart,
    dom: navigation.domContentLoadedEventEnd - navigation.responseEnd,
    load: navigation.loadEventEnd - navigation.navigationStart,
  };

  // アナリティクスサービスに送信
  sendToAnalytics('performance', metrics);
}

// ページロード完了後に実行
window.addEventListener('load', collectRUMData);
```

## まとめ

React アプリケーションのパフォーマンス最適化は以下のステップで進めましょう：

1. **測定**: React DevTools と Core Web Vitals で現状把握
2. **レンダリング最適化**: memo、useMemo、useCallback の適切な使用
3. **コード分割**: lazy loading と動的インポート
4. **状態管理**: Context の分割と軽量ライブラリの活用
5. **バンドル最適化**: Tree Shaking と Bundle Analyzer
6. **アセット最適化**: 画像フォーマットと Progressive Loading
7. **継続的監視**: 自動テストと RUM データ収集

これらの手法を組み合わせることで、ユーザー体験を大幅に改善できます。

---

## 関連記事

<LinkCardSimple 
  href="/blog/modern-web-development-2024/"
  title="2024年のモダンWeb開発トレンド"
  description="最新のWeb開発トレンドとパフォーマンス重視の開発手法"
/>

## 参考リンク

<LinkCard 
  href="https://react.dev/learn/render-and-commit"
  title="React - Render and Commit"
  description="Reactのレンダリングプロセスについての公式ドキュメント"
  external={true}
/>

<LinkCardSimple 
  href="https://web.dev/articles/react"
  title="React performance - web.dev"
  description="GoogleによるReactパフォーマンス最適化ガイド"
  external={true}
/>

<LinkCardSimple 
  href="https://github.com/GoogleChrome/lighthouse"
  title="Lighthouse"
  description="Webページの品質監査を自動化するオープンソースツール"
  external={true}
/>